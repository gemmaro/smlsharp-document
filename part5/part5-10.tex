\chapter{\txt
{構文論的解釈処理}
{Syntax Elaboration}
}
\label{chap:elaboration}

\ifjp%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
\begin{enumerate}
\item ソースロケーションとファイル構成

ディレクトリ \code{src/compiler/elaborate/main}下の以下のファイル
（とそれぞれに対応するインターフェイスファイル）からなる．

\begin{tabular}{ll}
\code{Elaborator.sml} & 構文解析後処理トップレベル\\
\code{ElaborateModule.sml} & モジュール言語の\\
\code{ElaborateInterface.sml} & インターフェイス言語の処理\\
\code{ElaborateCore.sml} & 核言語の処理．\\
\code{UserTvarScope.sml} & 型指定に現れる型変数のスコープの決定\\
\code{ElaborateSQL.sml} & SQL構文のコンパイル\\
\code{ElaboratorUtils.sml} & 種々の補助関数\\
\code{ElaborateErrorSQL.ppg} & SQL構文のコンパイルのエラー定義\\
\code{ElaborateError.ppg} & エラーメッセージの定義
\end{tabular}

\item 機能概要 

	型に依存しない構文論的な解釈を行う．
\begin{enumerate}
\item ２項演算子式のコンパイル
\item 糖衣構文の展開
\item 型変数のスコープの決定
\item SQL式のコンパイル
\item 多重定義のエラーチェック
\end{enumerate}

\item 他モジュールとのインターフェイス
\begin{itemize}
\item \code{src/compiler/toplevel2/main/Top.sml}からの
\code{Elaborator}
の呼び出し．
\item \code{src/compiler/toplevel2/main/TopData.ppg}から
\code{fixEnv}型の参照．
\end{itemize}
\end{enumerate}
\else%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fi%%%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


\section{\txt{\code{Elaborator.sml}の処理の詳細}{The details of \code{Elaborator.sml}}}
\ifjp%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	構文解析後処理トップレベル．
\subsection{インターフェイスファイル\code{Elaborator.smi}}
\begin{program}
structure Elaborator =\\
struct\\
\myem   type fixEnv = Fixity.fixity SEnv.map\\
\myem   val extendFixEnv : fixEnv * fixEnv -> fixEnv\\
\myem   val elaborate :\\
\myem \myem       fixEnv\\
\myem \myem       -> AbsynInterface.compileUnit\\
\myem \myem       -> fixEnv * PatternCalcInterface.compileUnit * UserError.errorInfo list\\
\myem   val elaborateInteractiveEnv :\\
\myem \myem       fixEnv\\
\myem \myem       -> AbsynInterface.interactiveUnit\\
\myem \myem       -> fixEnv * PatternCalcInterface.interactiveUnit * UserError.errorInfo list\\
end
\end{program}

\subsection{各関数の処理内容}
\begin{enumerate}
\item \code{elaborate}関数

	構文解析後処理のメイン関数．
	\module{toplevel2/main/}{Top.sml}の\code{compile}関数から
呼び出される．

\item \code{elaborateInteractiveEnv}関数

	\module{toplevel2/main/}{Top.sml}の\code{loadInteractiveEnv}
関数から呼び出され，対話型処理の環境構築のためのインタフェイスファイル構
文解析の後処理を行う．

\end{enumerate}
\else%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fi%%%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

\section{\txt{\code{ElaborateInterface.sml}の処理の詳細}{The details of \code{ElaborateInterface.sml}}}
\ifjp%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	インターフェイスの構文論的解釈処理．

\subsection{インターフェイスファイル\code{ElaborateInterface.smi}}
\begin{program}
structure ElaborateInterface =\\
\myem   struct\\
\myem\myem     type fixEnv = Fixity.fixity SEnv.map\\
\myem\myem     val elaborate\\
\myem\myem\myem   : AbsynInterface.interface -> fixEnv * PatternCalcInterface.interface\\
\myem\myem     val elaborateTopdecList\\
\myem\myem\myem   : AbsynInterface.itopdec list -> fixEnv * PatternCalcInterface.pitopdec list\\
\myem  end
\end{program}

\subsection{各関数の処理内容}
\begin{enumerate}
\item \code{elaborate}関数

	\code{Elaborator.elaborate}および
\code{Elaborator.elaborateInteractiveEnv}から呼び出され，インターフェイ
ス構文を処理．

\item \code{elaborateTopdecList}関数

\code{Elaborator.elaborateInteractiveEnv}から呼び出され，インターフェイス宣言文リストの処理を行う．

\end{enumerate}
\else%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fi%%%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

\section{\txt{\code{ElaborateModule.sml}の処理の詳細}{The details of \code{ElaborateModule.sml}}}
\ifjp%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	モジュール言語の処理．

\subsection{インターフェイスファイル\code{ElaborateModule.smi}}
\begin{program}
structure ElaborateModule =\\
\myem  struct\\
\myem\myem    val elabSigExp : Absyn.sigexp -> PatternCalc.plsigexp\\
\myem\myem    val elabTopDecs\\
\myem\myem\myem        : Fixity.fixity SEnv.map\\
\myem\myem\myem\myem          -> Absyn.topdec list\\
\myem\myem\myem\myem          -> PatternCalc.pltopdec list * Fixity.fixity SEnv.map\\
\myem  end
\end{program}
\subsection{各関数の処理内容}
\begin{enumerate}
\item \code{elabTopDecs}関数

	\code{Elaborator}から呼び出される\smlsharp{}言語の構文解析後処理
トップレベル関数．

\item \code{elabSigExp}関数

	シグネチャの処理を行う\code{elabTopDecs}の補助関数．
	\code{ElaborateInterface}からも呼び出される．

\end{enumerate}
\else%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fi%%%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


\section{\txt{\code{ElaborateCore.sml}の処理の詳細}{The details of \code{ElaborateCore.sml}}}
\ifjp%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

	核言語の構文論的解釈を行う．

\subsection{インターフェイスファイル\code{ElaborateCore.smi}}
\begin{program}
structure ElaborateCore =\\
struct\\
\myem  val elabDec 
\myem\myem
    : Fixity.fixity SEnv.map -> Absyn.dec -> PatternCalc.pdecl list * Fixity.fixity SEnv.map\\
\myem  val elabFFITy : Absyn.ffiTy -> PatternCalc.ffiTy\\
\myem  val checkReservedNameForConstructorBind : Symbol.symbol -> unit\\
\myem  val checkReservedNameForValBind : Symbol.symbol -> unit\\
end
\end{program}

\subsection{各関数の処理内容}
\begin{enumerate}
\item \code{elabDec}関数

以下の処理を行い，\code{Absyn.dec}を\code{PatternCalc.pdecl list}へ変換
し\code{fixEnv}を返す．
\begin{enumerate}
\item \code{infix}宣言を解釈し，２項演算子表現のコンパイル．
\item 以下の糖衣構文の展開．
\code{while}式，
\code{if}式，
\code{withtype}宣言付きのデータ型宣言．
\item 以下の名前の重複チェック．レコードラベル．型変パラメタ，データ型構
成子，同時変数宣言の変数名，同時型宣言の型構成子名，同時例外宣言の例外名．
\end{enumerate}
	
\item \code{elabFFITy}関数

レコードラベルの重複チェックを行い，\code{Absyn.ffity}を
\code{PatternCalc.ffiTy}に変換．

\item \code{checkReservedNameForConstructorBind}関数

	Standard MLでは，\code{true}，\code{false}，\code{nil}，
\code{ref}は再定義が禁止されている．
	本関数では，データ型定義に現れるコンストラクタ名にこれらが現れな
いかチェックを行う．
\item \code{checkReservedNameForValBind}関数

	Standard MLでは，\code{true}，\code{false}，\code{nil}，
\code{ref}は再定義が禁止されている．
	本関数では，変数束縛にこれらが現れないかチェックを行う．
\end{enumerate}

\else%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fi%%%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

\section{\txt{\code{UserTvarScope.sml}の処理の詳細}{The details of \code{UserTvarScope.sml}}}
\ifjp%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
	ユーザの型宣言に現れる型変数のスコープを決定する．
	以下の宣言に，その宣言をスコープとする明示的な型変数集合を設定す
る．
\begin{itemize}
\item 核言語の\code{val}宣言．
\item 核言語の\code{fun}宣言．
\item 核言語の\code{val rec}宣言．
\item シグネチャの\code{val}宣言．
\end{itemize}

\subsection{インターフェイスファイル\code{UserTvarScope.smi}}
\begin{program}
structure UserTvarScope =\\
\myem  struct\\
\myem\myem    type tvset (= boxed)\\
\myem\myem    val decide : PatternCalc.pltopdec list -> PatternCalc.pltopdec list\\
\myem\myem    val decideSigexp : PatternCalc.plsigexp -> PatternCalc.plsigexp\\
\myem\myem    val decideInterface : PatternCalcInterface.interface -> PatternCalcInterface.interface\\
\myem\myem    val decidePitopdecs :  PatternCalcInterface.pitopdec list -> PatternCalcInterface.pitopdec list\\
\myem  end
\end{program}
\else%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fi%%%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

\section{\txt{\code{ElaborateSQL.sml}の処理の詳細}{The details of \code{ElaborateSQL.sml}}}
\ifjp%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

	\smlsharp{}はデータベース問い合わせ言語SQLをシームレスに統合して
いる\cite{ohor89sigmod,bune96tods,ohori11}．
	その実装技術は，文献\cite{ohori11}で我々が提案した，以下のアイデ
アに基づくDSL言語の埋め込み戦略に基づく．
{
\newcommand{\dtype}{\mbox{$D$-{\it type}}}
\newcommand{\dexec}{\mbox{$D$-{\it exec}}}
\begin{enumerate}
\item \smlsharp{}で，DSLを模倣する「トイ言語」（データ型）を定義．
\item DSLの各構文$D$を，以下の２つの式の組みに変換．
\\[1ex]
\begin{tabular}{lcl}
\dtype &:& $D$を\smlsharp{}で模倣するトイ言語の式
\\
\dexec &:& \smlsharp{}からDSLライブラリを呼び出す命令列
\end{tabular}
\item \dtype{}に対して型推論し，結果を$D$の型（静的意味）とする．
\item \dtype{}を捨て，\dexec{}を実行するコードを生成する．
\end{enumerate}
}
	本モジュールは，この変換を実現する．

\subsection{インターフェイスファイル\code{ElaborateSQL.smi}}
\begin{program}
structure ElaborateSQL =\\
\myem  struct\\
\myem\myem     val elaborateExp\\
\myem\myem\myem   : \{elabExp:Absyn.exp -> PatternCalc.plexp,\\
\myem\myem\myem\myem\  elabPat:Absyn.pat -> PatternCalc.plpat\}\\
\myem\myem\myem\myem  -> (Absyn.exp,Absyn.pat,Absyn.ty) AbsynSQL.exp\\
\myem\myem\myem\myem  -> PatternCalc.plexp\\
\myem  end
\end{program}
	\code{elaborateExp}の本体は，\smlsharp{}に埋め込まれたSQL式
\code{AbsynSQL.exp}をSQL式を含まない\code{PatternCalc.plexp}に変換
である．
	第\ref{sec:AbsynSQL}項で説明した通り，SQL式は核言語の式
（\code{Absyn.exp}）とパターン（\code{Absyn.pat}）をパラメタとして取るパ
ラメタ型データ型として定義されている．
	\code{alaborateExp}の引数は，これら核言語の式とパターンを処理す
るための\code{ElaborateCore}の\code{elabExp}と\code{elabPat}である．


\else%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fi%%%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


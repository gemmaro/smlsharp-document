\chapter{\txt
{インターフェイスローダ：\code{loadfile}}
{The interface file loader : \code{loadfile}}
}
\label{chap:Loadfile}

\ifjp%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
\begin{enumerate}
\item ソースロケーションとファイル構成

ディレクトリ \code{src/compiler/loadfile/main}下の以下のファイルからなる．
\begin{itemize}
\item \code{LoadFile.sml} インタフェイスローダの処理ストラクチャ\code{LoadFile}を定義．
\item \code{interfaceHash.sml} SHA1関数を用いて，各インターフェイスファイルのID文字列を生成．
\item \code{SHA1.sml} SHA1アルゴリズムによるハッシュ値の計算．
\end{itemize}

\item 機能概要 
\begin{enumerate}
\item 
コンパイルソースファイルの\code{Absyn.compileUnit}を受け取り，ソー
スファイルに対応するインターフェイスファイルを読み込み，\code{\_require}
されているインタフェイスファイルを全て読み込み，
\code{AbsynInterfae.compileUnit}を生成する．
（\code{load}関数）
\item 
対話型モードのインターフェイスファイルを受け取り，対話型環境を構築する．
（\code{loadInteractiveEnv}関数）
\item 
インターフェイスファイルを受け取り，そのファイルをコンパイルおよびリンク
するために必要なファイル集合を返す．
（\code{generateDependency}関数）
\end{enumerate}
\item 他モジュールとのインターフェイス
\begin{itemize}
\item 
\code{src/compiler/toplevel2/main/Top.sml}から\code{LoadFile.load}関数の呼び出し．
\item 
\code{src/compiler/toplevel2/main/Top.sml}から\code{LoadFile.loadInteractiveEnv}関数の呼び出し．
\item 
\code{src/compiler/main/main/SimpleMain.sml}から
\code{generateDependency}関数の呼び出し．
\item \code{src/compiler/main/main/SimpleMain.sml}への\code{LoadFile.dependency}型を提供
\end{itemize}
\end{enumerate}
\else%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fi%%%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

\section{\txt{インターフェイスファイルのカテゴリ}{Interface file categories}}
	本モジュールを理解する上で，以下に記述する\smlsharp{}の入力ファ
イルの種類とその性質を理解する必要がある．
\begin{itemize}
\item プログラムソースファイル．
	通常\code{.sml}を拡張子とし，\smlsharp{}の宣言文の列を内容とする
ファイル．
	分割コンパイルの場合は，対応するインターフェイスファイルを通じて
利用される．
	対応するインターフェイスファイルは，\code{\_interface}宣言文で明
示的に定義されるか，拡張子\code{sml}を\code{smi}に変更したファイルが暗黙
に指定される．

\item インターフェイスファイル．
	プログラムが必要とするリソースの定義とプログラムが提供するリソー
スの定義からなるファイル．
	提供するリソースの定義は，インターフェイ宣言文の列であり，インターフェイ
スファイルに直接記述する．
	この宣言列をプロバイド宣言と呼ぶ．
	必要とするリソースの定義は，そのリソースを提供するインターフェイスファ
ウルを参照する\code{\_require}文の列である．

	インターフェイスファイルに対応してオブジェクトファイルが生成される．
	
\item インクルードファイル．
	シグネチャ定義，およびインタフェイスファイルまたはインクルードファ
イルへを参照する\code{include}文のみからなるファイル．
	インクルードファイルは，他のインターフェイスファイルからの
\code{\_require}文，または，他のインクルードファイルからの
\code{include}文を通じて参照される．
	\code{include}文による参照の効果は，参照されるファイルが参照位置
に展開されたと同一である．
	\code{\_require}文による参照の効果は，参照されるファイルのプロバ
イド宣言を参照位置に展開し，さらにシグネチャ宣言を，参照しているインタフェ
イスファイルを利用するソースファイルの先頭に展開することと同一である．

	インクルードファイルに対応するオブジェクトファイルは存在しない．
\end{itemize}
	以下は，簡単な例である．
\begin{quote}
\begin{tabular}{ll}
ファイル名 & 内容\\
\code{foo.sml} &
\begin{minipage}[b]{0.8\textwidth}
\begin{programPlain}
structure A : ASig =\\
struct\\
\myem  val x = B.y\\
end
\end{programPlain}
\end{minipage}
\\
\code{foo.smi} &
\begin{minipage}[b]{0.8\textwidth}
\begin{programPlain}
\_require "foo2.smi"\\
\-require "bar.sml"\\
val x : int
\end{programPlain}
\end{minipage}
\\
\code{foo2.smi} &
\begin{minipage}[t]{0.8\textwidth}
\begin{programPlain}
struccture B =\\
struct\\
\myem  val y : int\\
end
\end{programPlain}
\end{minipage}
\\
\code{bar.sml} &
\begin{minipage}[b]{0.8\textwidth}
\begin{programPlain}
include "bar2.sml"\\
signature BSig =\\
sig\\
\myem  val y : int\\
end
\end{programPlain}
\end{minipage}
\\
\code{bar2.sml} &
\begin{minipage}[b]{0.8\textwidth}
\begin{programPlain}
signature ASig =\\
sig\\
\myem  val x : int\\
end
\end{programPlain}
\end{minipage}
\end{tabular}
\end{quote}
	この例では，\code{foo.sml}がソースファイル，
\code{foo.sml}が\code{foo.smi}が対応するインターフェイスファイル，
\code{foo2.smi}が\code{foo.sml}が必要とする資源を提供するモジュールのイ
ンターフェイスファイル，\code{bar.sml}と\code{bar2.sml}の２つが
インクルードファイルである．
	これら２つのインクルードファイルで定義されたシグネチャは，
ソースファイル\code{foo.sml}および\code{foo2.smi}に対応するソースファイ
ルの中で有効になる．

\section{\txt{\code{LoadFile.sml}の処理の詳細}{The details of \code{LoadFile.sml}}}
\ifjp%>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

	ロードモジュールの機能を実現するファイルであり，\code{LoadFile}
ストラクチャを定義する．

\subsection{インターフェイスファイル\code{LoadFile.smi}}
\begin{program}
structure LoadFile =\\
struct\\
\myem  type dependency =\\
\myem\myem      \{interfaceNameOpt : AbsynInterface.interfaceName option,\\
\myem\myem\      link : AbsynInterface.interfaceName list,\\
\myem\myem\      compile : (AbsynInterface.filePlace * Filename.filename) list\}\\
\myem  val load\\
\myem\myem      : \{baseFilename: Filename.filename option,\\
\myem\myem\myem\         stdPath: Filename.filename list,\\
\myem\myem\myem\         loadPath: Filename.filename list\}\\
\myem\myem\myem\       -> Absyn.unit -> dependency * AbsynInterface.compileUnit\\
\myem  val generateDependency\\
\myem\myem      : \{stdPath: Filename.filename list,\\
\myem\myem\myem\         loadPath: Filename.filename list\}\\
\myem\myem\myem\        -> Filename.filename -> dependency\\
\myem  val loadInteractiveEnv\\
\myem\myem      : \{stdPath: Filename.filename list,\\
\myem\myem\myem\        loadPath: Filename.filename list\}\\
\myem\myem\myem\        -> Filename.filename -> AbsynInterface.interactiveUnit\\
end
\end{program}

\subsection{各関数の処理内容}
\begin{enumerate}
\item \code{load}関数
\begin{enumerate}
\item ソースファイルに対応するインターフェイスファイルを決定する
\item 対応するファイルが\code{INCLUDE}属性のファイルならエラーを報告．
\item インターフェイスファイルから参照されるインターフェ
イスファイルおよびインクルードファイルをよみ，\code{interface}型データを
構築
\item ソースファイルが依存するファイル集合を決定．
\end{enumerate}
	
\item \code{loadInteractiveEnv}関数
\begin{enumerate}
\item インターフェイスファイルから参照されるインターフェ
イスファイルおよびインクルードファイルをよみ，\code{interface}型データを
構築
\item 参照されるインターフェイスファイルすべての\code{provide}宣言を集め，
\code{interfaceDecls}として返す．
\end{enumerate}

\item \code{generateDependency}関数
\begin{enumerate}
\item インターフェイスファイルから参照されるインターフェイスファイルおよ
びインクルードファイルをよみ，\code{dependency}型データを構築する．
\end{enumerate}
\end{enumerate}

\subsection{使用するデータ構造と補助関数}

\begin{enumerate}
\item 外部で定義されたデータ構造
\begin{itemize}
\item \code{AbsynInterface.source}
	ファイルファイルの位置（ライブラリパス上，ローカルパス上）とファイル名の組み．
\item \code{AbsynInterface.interfaceName}
	インターフェイスファイル名とそのハッシュ値をもったデータ構造．
\item \code{Absyn.unit} トップレベルソースコード（コンパイル単位）
\begin{program}
type unit = \{interface : interface, tops : top list,loc : loc\}
\end{program}
\item \code{Absyn.interface}
	ソースファイル中の明示的なインターフェイスファイル指定の有無．
\begin{program}
datatype interface = INTERFACE of Symbol.symbol | NOINTERFACE
\end{program}
\item \code{AbsynInterface.itop}
	インターフェイスファイルの構文解析結果．
\begin{program}
datatype itop\\
\myem  = INTERFACE of \{requires: symbol list, provide: itopdec list\}\\
\myem  | INCLUDES of \{includes: symbol list, topdecs: Absyn.topdec list\}
\end{program}
	\code{INTERFACE}バリアントはインターフェイスファイルを，
\code{INCLUDE}バリアントはインクルードをファイルを意味する．

\end{itemize}
\item 外部へ提供するデータ構造
\begin{itemize}
\item 
\begin{programPlain}
type dependency =\\
\myem      \{interfaceNameOpt : AbsynInterface.interfaceName option,\\
\myem\      link : AbsynInterface.interfaceName list,\\
\myem\      compile : AbsynInterface.source  list\}\\
\end{programPlain}

	ソースファイルまたはインターフェイスが依存するファイル集合を表す
データ構造．
\begin{itemize}
\item \code{interfaceNameOpt} 
	インターフェイスがある場合はその名前．
	インターフェイスファイルを持たないトップレベルのソースファイルに
対してはこのフィールドは\code{NONE}である．
	この場合，\code{link}フィールドは空リストであるが，ソースファイ
ルが\code{use}文を用いて他のファイルを利用している場合は，\code{compile}
フィールドにそのファイルリストが設定される．

\item \code{link}
	ソースファイルが依存するインターフェイスファイルのリスト．
	このリストが，ソースファイルをリンクするために必要とされるオブジェ
クトファイルに対応する．

\item \code{compile}
	ソースファイルが依存するインターフェイスファイル，インクルードファ
イル，及びユースファイルのリスト．
\end{itemize}
\end{itemize}
\item 使用するデータ構造
\begin{itemize}
\item \code{type env = \{baseDir : I.source option, visited : SSet.set\}}
\begin{itemize}
\item \code{baseDir}：参照元のファイルがあるディレクトリ．
\item \code{visited}：インターフェイスファイル参照の循環をチェックするための読み込み済みのファイル名集合．
\end{itemize}
	
\item 
\begin{programPlain}
type loadAccum =\\
\myem      \{\\
\myem\         loadCount : int ref,\\
\myem\         smiFileMap : result SEnv.map ref,\\
\myem\         smlFileMap : A.unitparseresult SEnv.map ref,\\
\myem\         interfaceDecsRev : I.interfaceDec list ref,\\
\myem\         loadedFiles : I.source list ref\\
\myem       \}
\end{programPlain}

	解析対象ファイルが参照するファイル集合を記録するデータ構造．
\begin{itemize}
\item \code{loadCount} 今回解析対象となったファイルに依存するファイルへ
通し番号を付けるためのカウンタ．
	ファイルの\code{LoadedMap}のキー．
\item \code{smiFileMap} 文で参照されたインターフェイスソースファイルの内容をもつ辞書．
\item \code{smlFileMap} \code{use}文で参照されたソースファイルの内容をも
つ辞書．
\item \code{interfaceDecsRev} \code{AbsynInterface.ppg}のインターフェイ
スデータ構造の中の\code{interface}型の逆順
\end{itemize}
\item 
\begin{programPlain}
type result =\\
\myem \{requiredIdHashes : (\{id: InterfaceID.id, loc: I.loc\} * string) LoadedMap.map,\\
\myem\  topdecs : A.topdec list LoadedMap.map\}
\end{programPlain}

	インターフェイスファイルで参照されるインターフェイスファイルまた
はインクルードファイルの解析結果をもつ辞書．
	キーは，\code{loadAccum}の\code{loadCount}で生成されるファイルの
通し番号．

\item 
\begin{programPlain}
datatype parseResult =\\
\myem\ \ LOADED of result\\
\myem  | PARSED of env * I.source * I.itop
\end{programPlain}
\end{itemize}

\item 主な補助関数の機能概要
\begin{itemize}
\item 
\code{newLoadAccum} 辞書の初期化
\item 
\code{newLoadedKey} 辞書登録キーの生成
\item 
\code{findLoaded} 確定したインターフェイスファイルまたはインクルードファイルが登録済みか検索
\item 
\code{addResult} インターフェイスファイルを辞書に登録
\item 
\code{addInterface} インターフェイスファイルローカル定義を辞書に追加
\item 
\code{addUse} ユースファイルを辞書に追加
\item 
\code{appendNewTopdec} インクルードファイルの本体（宣言）を辞書に追加
\item 
\code{appendResult} 解析結果辞書をマージ
\item 
\code{mkDependency} 辞書に登録された内容を\code{dependency}型データとして取り出す．
\item 
\code{newRequireEntry} インターフェイスに対する辞書キーを割り当て，解析
結果を生成．
	辞書への登録は行わない．
\item 
\code{openFile} ファイル名の形式に従い，ファイル位置を探索しオープンする．
\item 
\code{openFileOnPath} ファイル名をオープンする．
\item 
\code{openLocalFile} ロードパスを一つ順に探索しファイルをオープンする．
\item 
\code{visitFile} ファイルが探索済みかをチェックし，新しいファイルを環境に登録．
\item 
\code{parseInterface} ファイルがロード済であれば結果を，それ以外はファイルの中身の構文解析結果を返す．
\item 
\code{setupInterface} インターフェイスファイルの解析結果を受け取り，ハッシュ値を計算する．
\item 
\code{loadRequires} 参照されているインターフェイスまたはインクルードファ
イルをすべてたどり，辞書に登録し，結果を返す．
\item 
\code{parseSource} ユースファイルがロード済みかをチェックし，ロード済み
でなければ構文解析し，辞書に登録し，結果を返す．
\item 
\code{includeUseFiles} ソースファイルの\code{use}文を展開する．
\item 
\code{defaultInterface} 暗黙のインターフェイスファイルを推定する．
\end{itemize}
\end{enumerate}

\else%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fi%%%%<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

